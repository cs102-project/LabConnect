package me.labconnect.webapp.models.testing;

import org.springframework.data.annotation.PersistenceConstructor;

import java.io.IOException;
import java.lang.ProcessBuilder.Redirect;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * A model of a single unit test, with one tester class and a correct output.
 * <p>
 * The test is done by comparing the output of the tester with the output generated by the example
 * implementation
 *
 * @author Berkan Åžahin
 * @version 01.05.2021
 */
public class UnitTest implements Tester {

    // Variables
    private String name;
    private ArrayList<String> correctOutput;
    private Long timeLimitInMS;
    private String testerClassPath;

    // Constructors

    /**
     * Initializes a new unit test for which the correct output is already known.
     * <p>
     * This constructor is intended to be used when retrieving unit test entries from a database.
     *
     * @param name            The name of the unit test
     * @param correctOutput   The output generated by the example implementation supplied by the
     *                        instructor
     * @param timeLimitInMS   The time limit for this test in milliseconds. A value of 0 denotes no
     *                        time limit.
     * @param testerClassPath The absolute path to the tester class, which is a singular .java file
     *                        with a main method.
     */
    @PersistenceConstructor
    public UnitTest(String name, ArrayList<String> correctOutput, Long timeLimitInMS,
                    String testerClassPath) {
        this.name = name;
        this.correctOutput = correctOutput;
        this.timeLimitInMS = timeLimitInMS;
        this.testerClassPath = testerClassPath;
    }

    /**
     * Creates a new unit test from the given tester and generates the correct output from the example
     * implementation
     *
     * @param name                  The name of this test
     * @param testerClass           The tester class, which is a singular java file with a main
     *                              method
     * @param exampleImpl           The example implementation supplied by the instructor
     * @param timeLimitMilliseconds The maximum time for the unit test in milliseconds. A value of 0
     *                              denotes no time limit
     * @throws IOException         If an I/O problem is encountered while processing the
     *                             implementation or tester files
     * @throws BadExampleException If the example implementation fails the unit test
     * @implNote the tester class is copied to the assignment directory, therefore it is safe to
     * delete it afterwards
     */
    public UnitTest(String name, Path testerClass, Path exampleImpl, long timeLimitMilliseconds)
            throws IOException, BadExampleException {
        final String TESTER_ROOT = "/var/labconnect/assignments/tests";

        TestResult firstResult;

        this.name = name;
        this.timeLimitInMS = timeLimitMilliseconds;

        testerClassPath = Files
                .copy(testerClass,
                        Files.createTempDirectory(Files.createDirectories(Paths.get(TESTER_ROOT)), "")
                                .resolve(testerClass.getFileName()))
                .toString();

        firstResult = runTest(extractExampleImpl(exampleImpl));
        if (!firstResult.isSuccessful()) {
            throw new BadExampleException(firstResult);
        } else {
            correctOutput = firstResult.getOutput();
        }
    }

    /**
     * Creates a new unit test from the given tester and generates the correct output from the example
     * implementation
     *
     * @param name        The name of this test
     * @param testerClass The tester class, which is a singular java file with a main method
     * @param exampleImpl The example implementation supplied by the instructor
     * @throws IOException         If an I/O problem is encountered while processing the
     *                             implementation or tester files
     * @throws BadExampleException If the example implementation fails the unit test
     * @implNote The tester class is copied to the assignment directory, therefore it is safe to
     * delete it afterwards
     */
    public UnitTest(String name, Path testerClass, Path exampleImpl)
            throws IOException, BadExampleException {
        this(name, testerClass, exampleImpl, 0);
    }

    // Methods

    /**
     * A helper method that extracts the example implementation uploaded by the instructor
     *
     * @param exampleImpl The example implementation as a .zip file
     * @return The directory the archive is extracted to
     * @throws IOException If extracting the example fails
     */
    private Path extractExampleImpl(Path exampleImpl) throws IOException {
        Path extractionDir;
        ArrayList<String> extractorArgs;
        ProcessBuilder extractorBuilder;
        Process extractor;

        if (Files.isDirectory(exampleImpl)) {
            return exampleImpl;
        }
        if (!exampleImpl.isAbsolute() || !exampleImpl.toString().endsWith(".zip")) {
            throw new IOException("Invalid archive");
        }

        // Create extraction dir
        extractionDir = Files.createTempDirectory("");

        // Unzip example
        extractorArgs = new ArrayList<>();
        extractorArgs.add("unzip");

        // Rest of the args are derived from unzip manpage
        extractorArgs.add("-oqq"); // Overwrite existing files and suppress output

        extractorArgs.add(exampleImpl.toString());

        // Extract to the newly created dir
        extractorArgs.add("-d");
        extractorArgs.add(extractionDir.toString());

        extractorBuilder = new ProcessBuilder(extractorArgs);
        extractorBuilder.redirectOutput(Redirect.DISCARD);
        extractor = extractorBuilder.start();

        // Wait for extraction to end, then determine success from exit code
        try {
            if (extractor.waitFor() != 0) {
                throw new IOException("Extraction error");
            }
        } catch (InterruptedException e) {
            throw new IOException("unzip was interrupted");
        }

        return extractionDir;
    }

    /**
     * Compiles the tester together with the given source code submission
     *
     * @param source The directory containing the submission code
     * @return The directory containing the resulting bytecode
     * @throws IOException          If the Path in the parameter is not a directory, or if I/O
     *                              operations on the source directory fail
     * @throws CompilationException If compilation of the provided source code fails
     */
    private Path compileSubmission(Path source) throws IOException, CompilationException {
        Path compilerOutput;
        Path bytecodeDirectory;
        List<String> sourceFiles;
        ArrayList<String> compilerArgs;
        ProcessBuilder compilerBuilder;
        Process compilerProcess;

        if (!Files.isDirectory(source) /* || !source.isAbsolute() */) {
            throw new IOException();
        }

        Files.copy(getTesterClass(), source.resolve(getTesterClass().getFileName()));

        // Scan the source path for .java files
        sourceFiles = Files.walk(source).map(Path::toString).filter(s -> s.endsWith(".java"))
                .collect(Collectors.toList());

        bytecodeDirectory = Files.createTempDirectory(null);
        compilerOutput = Files.createTempFile("javac-", ".out");

        // Generate the arguments
        compilerArgs = new ArrayList<>();

        compilerArgs.add("javac");

        // Specify output directory (source: javac manpage)
        compilerArgs.add("-d");
        compilerArgs.add(bytecodeDirectory.toString());

        compilerArgs.addAll(sourceFiles);

        compilerBuilder = new ProcessBuilder(compilerArgs);
        compilerBuilder.redirectOutput(compilerOutput.toFile());

        compilerProcess = compilerBuilder.start();

        // Wait until the compiler exits then check its return code
        try {
            compilerProcess.waitFor();

            Files.deleteIfExists(source.resolve(getTesterClass().getFileName()));

            if (compilerProcess.exitValue() != 0) {
                throw new CompilationException(compilerOutput);
            }
        } catch (InterruptedException e) {
            Files.deleteIfExists(source.resolve(getTesterClass().getFileName()));
            throw new CompilationException(compilerOutput);
        }

        return bytecodeDirectory;
    }

    /**
     * Compile and test the given submission against the tester class
     *
     * @param submission The submission to test
     * @return A TestResult instance
     * @throws IOException If an I/O error occurs while processing the submission
     */
    @Override
    public TestResult runTest(Path submission) throws IOException {
        final String DIFF_TEMPLATE = "Expected %s, got %s";

        Path bytecodeDir;
        Path programOutput;
        ProcessBuilder runtimeBuilder;
        Process runtimeProcess;
        ArrayList<String> runtimeArgs;
        ArrayList<String> offendingLines;
        String testerFileName;
        String testerClassName;
        String currentLine;
        TestState endState;
        Scanner currentOutputScanner;
        boolean finishedInTime;

        // Try to compile the submission
        try {
            bytecodeDir = compileSubmission(submission);
        } catch (CompilationException e) {
            return new TestResult(this, submission, e);
        }

        // Extract class name from tester filename
        testerFileName = getTesterClass().getFileName().toString();
        testerClassName = testerFileName.substring(0, testerFileName.length() - 5);

        programOutput = Files.createTempFile("runtime-", ".out");

        // Specify the runtime command
        runtimeArgs = new ArrayList<>();
        runtimeArgs.add("java");

        // Add the bytecode dir as a classpath
        runtimeArgs.add("-cp");
        runtimeArgs.add(bytecodeDir.toString());

        runtimeArgs.add(testerClassName);

        runtimeBuilder = new ProcessBuilder(runtimeArgs);
        runtimeBuilder.redirectOutput(programOutput.toFile());

        runtimeProcess = runtimeBuilder.start();

        // Wait until specified time limit or until the process exits
        try {
            if (timeLimitInMS > 0) {
                finishedInTime = runtimeProcess.waitFor(timeLimitInMS, TimeUnit.MILLISECONDS);
            } else {
                runtimeProcess.waitFor();
                finishedInTime = true;
            }
        } catch (InterruptedException e) {
            return new TestResult(this, submission, programOutput, TestState.RUNTIME_ERROR);
        }

        // Determine end state
        if (!finishedInTime) {
            endState = TestState.TIMEOUT;
        } else if (runtimeProcess.exitValue() != 0) {
            endState = TestState.RUNTIME_ERROR;
        } else if (correctOutput == null) { // Check if this is the example run
            endState = TestState.SUCCESS;
        } else {

            currentOutputScanner = new Scanner(programOutput);
            offendingLines = new ArrayList<>();

            for (String correctLine : correctOutput) {
                if (!currentOutputScanner.hasNextLine()) {
                    offendingLines.add(String.format(DIFF_TEMPLATE, correctLine, "EOF"));
                } else {
                    currentLine = currentOutputScanner.nextLine();
                    if (!correctLine.equals(currentLine)) {
                        offendingLines.add(String.format(DIFF_TEMPLATE, correctLine, currentLine));
                    }
                }
            }

            // If both files don't reach EOF at the same time, they are different
            while (currentOutputScanner.hasNextLine()) {
                offendingLines.add(String.format(DIFF_TEMPLATE, "EOF", currentOutputScanner.nextLine()));
            }

            currentOutputScanner.close();

            if (offendingLines.isEmpty()) {
                endState = TestState.SUCCESS;
            } else {
                endState = TestState.OUTPUT_MISMATCH;
                return new TestResult(this, submission, offendingLines, endState);
            }
        }

        return new TestResult(this, submission, programOutput, endState);

    }

    /**
     * Returns the name of the test
     *
     * @return the name of the test
     */
    @Override
    public String getName() {
        return name;
    }

    /**
     * Return the correct output as a list of lines
     *
     * @return the correct output as a list of lines
     */
    public ArrayList<String> getCorrectOutput() {
        return correctOutput;
    }

    /**
     * Return the time limit in milliseconds. 0 means no time limit.
     *
     * @return the time limit in milliseconds
     */
    public Long getTimeLimitInMS() {
        return timeLimitInMS;
    }

    /**
     * Return the tester class as a Path object
     *
     * @return the tester class
     */
    private Path getTesterClass() {
        return Paths.get(testerClassPath);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        UnitTest unitTest = (UnitTest) o;
        return Objects.equals(name, unitTest.name) && Objects
                .equals(correctOutput, unitTest.correctOutput) && Objects
                .equals(timeLimitInMS, unitTest.timeLimitInMS) && Objects
                .equals(testerClassPath, unitTest.testerClassPath);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, correctOutput, timeLimitInMS, testerClassPath);
    }
}
